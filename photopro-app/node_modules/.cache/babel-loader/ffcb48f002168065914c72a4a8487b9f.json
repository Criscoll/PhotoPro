{"ast":null,"code":"import { CodedError } from '@unimodules/core';\nimport * as React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport { CameraType } from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\nconst ExponentCamera = React.forwardRef(({\n  type,\n  pictureSize,\n  ...props\n}, ref) => {\n  const video = React.useRef(null);\n  const native = useWebCameraStream(video, type, props, {\n    onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n\n    onMountError: props.onMountError\n  });\n  const isQRScannerEnabled = React.useMemo(() => {\n    return !!(props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned);\n  }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n  useWebQRScanner(video, {\n    interval: props.barCodeScannerSettings?.interval,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === CameraType.front\n    },\n\n    onScanned(event) {\n      if (props.onBarCodeScanned) {\n        props.onBarCodeScanned(event);\n      }\n    }\n\n  }); // const [pause, setPaused]\n\n  React.useImperativeHandle(ref, () => ({\n    async getAvailablePictureSizes(ratio) {\n      return PictureSizes;\n    },\n\n    async takePicture(options) {\n      if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n        throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n      }\n\n      const settings = native.mediaTrackSettings;\n\n      if (!settings) {\n        throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n      }\n\n      return capture(video.current, settings, { ...options,\n\n        // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n        onPictureSaved(picture) {\n          if (options.onPictureSaved) {\n            options.onPictureSaved(picture);\n          }\n\n          if (props.onPictureSaved) {\n            props.onPictureSaved({\n              nativeEvent: {\n                data: picture,\n                id: -1\n              }\n            });\n          }\n        }\n\n      });\n    },\n\n    async resumePreview() {\n      if (video.current) {\n        video.current.play();\n      }\n    },\n\n    async pausePreview() {\n      if (video.current) {\n        video.current.pause();\n      }\n    }\n\n  }), [native.mediaTrackSettings, props.onPictureSaved]); // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n  // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n\n  const isMuted = true;\n  const style = React.useMemo(() => {\n    const isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [StyleSheet.absoluteFill, styles.video, {\n      // Flip the camera\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [native.type]);\n  return React.createElement(View, {\n    pointerEvents: \"box-none\",\n    style: [styles.videoWrapper, props.style]\n  }, React.createElement(Video, {\n    autoPlay: true,\n    playsInline: true,\n    muted: isMuted,\n    // webkitPlaysinline\n    pointerEvents: props.pointerEvents,\n    ref: video,\n    style: style\n  }), props.children);\n});\nexport default ExponentCamera;\nconst Video = React.forwardRef((props, ref) => createElement('video', { ...props,\n  ref\n}));\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"sources":["../src/ExponentCamera.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import { CodedError } from '@unimodules/core';\nimport * as React from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraCapturedPicture,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = React.forwardRef(\n  (\n    { type, pictureSize, ...props }: CameraNativeProps & { children?: React.ReactNode },\n    ref: React.Ref<ExponentCameraRef>\n  ) => {\n    const video = React.useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, type as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = React.useMemo<boolean>(() => {\n      return !!(\n        props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned\n      );\n    }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: props.barCodeScannerSettings?.interval,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === CameraType.front },\n      onScanned(event) {\n        if (props.onBarCodeScanned) {\n          props.onBarCodeScanned(event);\n        }\n      },\n      // onError: props.onMountError,\n    });\n\n    // const [pause, setPaused]\n\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(ratio: string): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = React.useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          // webkitPlaysinline\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = React.forwardRef(\n  (\n    props: React.ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n    },\n    ref: React.Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}