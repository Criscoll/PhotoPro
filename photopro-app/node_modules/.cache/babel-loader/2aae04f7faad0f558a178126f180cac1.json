{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nexport const userMediaRequested = false;\nexport const mountedInstances = [];\n\nasync function requestLegacyUserMediaAsync(props) {\n  const optionalSource = id => ({\n    optional: [{\n      sourceId: id\n    }]\n  });\n\n  const constraintToSourceId = constraint => {\n    const {\n      deviceId\n    } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId) && deviceId.length > 0) {\n      return deviceId[0];\n    }\n\n    if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources = await new Promise(resolve => // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n  MediaStreamTrack.getSources(sources => resolve(sources)));\n  let audioSource = null;\n  let videoSource = null;\n  sources.forEach(source => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(isMuted, audioConstraints, videoConstraints) {\n  const constraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(props, isMuted = true) {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\nexport async function getAnyUserMediaAsync(constraints, ignoreConstraints = false) {\n  try {\n    return await getUserMediaAsync({ ...constraints,\n      video: ignoreConstraints || constraints.video\n    });\n  } catch (error) {\n    if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n\n    throw error;\n  }\n}\nexport async function getUserMediaAsync(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n\n  return new Promise((resolve, reject) => _getUserMedia.call(navigator, constraints, resolve, reject));\n}\nexport function canGetUserMedia() {\n  return (// SSR\n    canUseDOM && // Has any form of media API\n    !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'])\n  );\n}\nexport async function isFrontCameraAvailableAsync(devices) {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\nexport async function isBackCameraAvailableAsync(devices) {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(labels, type, devices) {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n\n  const cameras = devices.filter(t => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter(camera => labels.some(label => camera.label.toLowerCase().includes(label)));\n  const [isCapable] = cameras.filter(camera => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = camera.getCapabilities();\n\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find(_ => type);\n  });\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}","map":{"version":3,"sources":["../src/WebUserMediaManager.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(props): Promise<any[]> {\n  const optionalSource = id => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = constraint => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId) && deviceId.length > 0) {\n      return deviceId[0];\n    }\n\n    if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise(resolve =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources(sources => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach(source => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error) {\n    if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  return (\n    // SSR\n    canUseDOM &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter(t => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter(camera =>\n    labels.some(label => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter(camera => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}